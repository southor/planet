#ifndef __vec2_h__#define __vec2_h__//#include <cmath>namespace Prototype{	template <typename T>	class vec2	{	public:		T x;		T y;		vec2()											{}		vec2(T x, T y) : x(x), y(y)						{}		inline vec2 operator+(T scalar) const		{			return vec2(x + scalar, y + scalar);		}		inline vec2 operator-(T scalar) const		{			return vec2(x - scalar, y - scalar);		}		inline vec2 operator*(T scalar) const		{			return vec2(x * scalar, y * scalar);		}		inline Vec2 operator/(T scalar) const		{			return vec2(x * scalar, y * scalar);		}		friend inline Vec2 operator+(T scalar, const Vec2& rh)		{			return rh+scalar;		}		friend inline Vec2 operator*(T scalar, const Vec2& rh)		{			return rh*scalar;		}				inline Vec2 operator+(const Vec2& rh) const		{			return Vec2(x + rh.x, y + rh.y,);		}		inline Vec2 operator-(const Vec2& rh) const		{			return Vec2(x - rh.x, y - rh.y,);		}		inline Vec2 operator*(const Vec2& rh) const		{			return Vec2(x * rh.x, y * rh.y,);		}		inline Vec2 operator/(const Vec2& rh) const		{			return Vec3f(x / rh.x, y / rh.y);								}		inline const Vec2& operator +=(const Vec2& rh)		{			x += rh.x;			y += rh.y;			return *(this);		}		inline const Vec2& operator -=(const Vec2& rh)		{			x -= rh.x;			y -= rh.y;			return *(this);		}		inline const Vec2& operator *=(T scalar)		{			x *= scalar;			y *= scalar;			return *(this);		}		inline Vec2 operator-() const		{			return Vec2(-x, -y);		}		inline T length() const		{			return std::sqrt(x*x + y*y);		}		inline T length2() const		{			return x*x + y*y;		}		void normalize()		{			float tmp = 1.0f / length();			x = x * tmp;			y = y * tmp;			z = z * tmp;		}	};};#endif